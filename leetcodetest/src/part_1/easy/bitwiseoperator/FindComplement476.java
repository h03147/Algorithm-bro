package part_1.easy.bitwiseoperator;

public class FindComplement476 {

    public int findComplement(int num) {
        /**
         * 分析题意：题目要求我们找到一个正整数二进制数的补数，即所有位按位取反即可。取反我们很容易想到异或。
         * 我们用掩码（位掩码）来与原码做异或运算，会更快找到补数。举例子
         * 例如 5的二进制表示为 101 ，为了按异或取反，我们可以找到一个掩码 111 ，这样这个掩码和原码进行位运
         * 算（异或）可以达到我们需要求补数的目的，101 ^ 111 = 010 结果对应十进制数为 2。验证成功
         */

        // 正整数 有符号最高位为0，还剩下31位，1左移30位使其到可能的最高位1
        int mask = 1 << 30;
        //循环找num中的最高位1在哪一位，找到了循环结束，mask的1停留在与num最高位1相同位置做标记
        while((num & mask) == 0) mask >>= 1;
        // 然后mask左进一位再减1就得到了我们需要的和num位数相同，全1的掩码
        mask = (mask << 1) - 1;
        // 然后异或就是补数
        return num ^ mask;
    }

}
